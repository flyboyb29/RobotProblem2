#pragma config(Sensor, S1,     ColorSensorL,   sensorEV3_Color)
#pragma config(Sensor, S2,     Sonar,          sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     ColorSensorR,   sensorEV3_Color)
#pragma config(Motor,  motorA,          MotorR,        tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorB,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorD,          MotorL,        tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Colour sensor modes
0 - modeEV3Color_Reflected
1 - modeEV3Color_Ambient
2 - modeEV3Color_Color
3 - modeEV3Color_Reflected_Raw
4 - modeEV3Color_RGB_Raw
5 - modeEV3Color_Calibration - Not utilized
*/

int whiteLowerThreshold = 12;
int greyLowerThreshold = 5;
int detectObjectFarThreshold = 36;
int detectObjectLowThreshold = 1;
int objectDetectMaxSpeed = 100;
float currentDistance = 0;
int manuverSpeed = 20;

enum mode {
	wander,
	getOnLine,
	stayOnLine,
	object,
	leaveObject
};
mode Mode = stayOnLine;
char greySide;

task objectDetect () {
	while(true && Mode != leaveObject) {
		// Read the sensor
		currentDistance = SensorValue[Sonar] /2.54;
		displayCenteredBigTextLine(8, "Dist: %f.2 in", currentDistance);
		if ((currentDistance) <= detectObjectFarThreshold && currentDistance > detectObjectLowThreshold)
		{
			Mode = object;
			} else if (currentDistance <= detectObjectLowThreshold){
			//turn around  and resume wander
			Mode = leaveObject;
			} else {
			//lost sight of object
			Mode = wander;
		}
	}
}

task lineDetect () {
	while(true) {
		if (Mode == wander) {
			int currentLvalue = SensorValue[ColorSensorL];
			int currentRvalue = SensorValue[ColorSensorR];
			if (currentLvalue < whiteLowerThreshold && currentRvalue < whiteLowerThreshold) {
				Mode = getOnLine;
				int choose = rand() % 2 + 1;
				if (choose == 1) {
					greySide = 'R';
					} else {
					greySide = 'L';
				}
				} else if (currentRvalue < whiteLowerThreshold) { //right sensor hits black
				//turn left
				greySide = 'R';
				Mode = getOnLine;	
			}

			//left sensor hits black
			else if (currentLvalue < whiteLowerThreshold) {
				//turn right
				greySide = 'L';
				Mode = getOnLine;	

			} 
			if (Mode == getOnLine) {
				if (greySide == 'L') {
					//turn left
					motor[MotorL] = 0;
					motor[MotorR] = manuverSpeed;
					} else {
					//turn right
					motor[MotorL] = manuverSpeed;
					motor[MotorR] = 0;
				}
			}
			} else if (Mode == getOnLine) {
			//follow a line
			} else if (Mode == stayOnLine) {

		}
	}
}

task main()
{

	startTask(objectDetect);
	startTask(lineDetect);



	//for testing object detect
	//const int distanceToMaintain = 30;
	motor[MotorL] = manuverSpeed;
	motor[MotorR] = manuverSpeed;
	while (true)
	{
		displayCenteredBigTextLine(1, "M: %s", Mode);
		if (Mode == stayOnLine) {
			greySide = 'R';
			// Write the amount of reflected light to the screen
			// This is a value between 0 and 100, where 0 means no reflected
			// light and 100 means all light is being reflected
			int currentLvalue = SensorValue[ColorSensorL];
			int currentRvalue = SensorValue[ColorSensorR];
			displayBigTextLine(3, "ReflectedL: %d", currentLvalue);
			displayBigTextLine(5, "ReflectedR: %d", currentRvalue);
			if (greySide == 'R') {
				//in grey area
				if (currentRvalue >= greyLowerThreshold && currentRvalue <= whiteLowerThreshold) {
					motor[MotorL] = manuverSpeed;
					motor[MotorR] = manuverSpeed;
					} else if (currentRvalue <= greyLowerThreshold) {
					//in black area so turn left
					int difference = greyLowerThreshold - currentRvalue;
					//displayCenteredBigTextLine(4, "speRat %f.2", speedRatio);
					float currentSpeed = manuverSpeed + difference * 3;
					//displayCenteredBigTextLine(6, "currSpe %f.2", currentSpeed);
					motor[MotorL] = manuverSpeed;
					motor[MotorR] = currentSpeed;
					} else if (currentRvalue >= whiteLowerThreshold) {
					//in white area so turn right
					int difference = currentRvalue - whiteLowerThreshold;
					//displayCenteredBigTextLine(4, "speRat %f.2", speedRatio);
					float currentSpeed = manuverSpeed + difference * 3;
					//displayCenteredBigTextLine(6, "currSpe %f.2", currentSpeed);
					motor[MotorL] = currentSpeed;
					motor[MotorR] = manuverSpeed;
				}

			}//end greyside == 'R'


			// Wait 20 ms to get 50 readings per second
			sleep(20);
			} else if (Mode == getOnLine) {
			int currentLvalue = SensorValue[ColorSensorL];
			int currentRvalue = SensorValue[ColorSensorR];
			displayBigTextLine(3, "ReflectedL: %d", currentLvalue);
			displayBigTextLine(5, "ReflectedR: %d", currentRvalue);


			} else if (Mode == object) {



			//this must be in a task


			// We're too far away, ignore
			if ((currentDistance) <= detectObjectFarThreshold && currentDistance > detectObjectLowThreshold)
			{

				float speedRatio = (currentDistance) / detectObjectFarThreshold;
				displayCenteredBigTextLine(4, "speRat %f.2", speedRatio);
				float currentSpeed = speedRatio * objectDetectMaxSpeed;
				displayCenteredBigTextLine(6, "currSpe %f.2", currentSpeed);
				motor[MotorL] = currentSpeed;
				motor[MotorR] = currentSpeed;
				} else {
				displayCenteredBigTextLine(1, "not Adv ");
				motor[MotorL] = 0;
				motor[MotorR] = 0;
			}


			//Loop to monitor value in Sensor debugger window
			sleep(50);

			} else if (Mode == wander) {

			} else if (Mode == leaveObject) {
			//backup
			motor[MotorL] = -20;
			motor[MotorR] = -20;
			sleep(2000);
			//turn around
			motor[MotorL] = 20;
			motor[MotorR] = -20;
			sleep(2000);
			//pause
			motor[MotorL] = 0;
			motor[MotorR] = 0;
			sleep(2000);
			Mode=wander;
			startTask(objectDetect);
		}

	} //end while true
} //end task main
