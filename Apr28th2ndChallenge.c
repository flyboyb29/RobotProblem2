#pragma config(Sensor, S1,     ColorSensorR,   sensorEV3_Color)
#pragma config(Sensor, S2,     Sonar,          sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     ColorSensorL,   sensorEV3_Color)
#pragma config(Motor,  motorA,          MotorR,        tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorD,          MotorL,        tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
int VEER_RIGHT_CHANCE = 50;
int VEER_SPEED_OFFSET = 25;
//int TURN_SPEED_OFFSET = 10;
int DISTRO_OFFSET = 10;
int SWERVE_DUR_MIN = 500;
int SWERVE_DUR_MAX = 1500;
/*
Colour sensor modes
0 - modeEV3Color_Reflected
1 - modeEV3Color_Ambient
2 - modeEV3Color_Color
3 - modeEV3Color_Reflected_Raw
4 - modeEV3Color_RGB_Raw
5 - modeEV3Color_Calibration - Not utilized
*/

int whiteLowerThreshold = 20;
int greyLowerThreshold = 8; //5
int detectObjectFarThreshold = 36;
float detectObjectLowThreshold = 1.9;
int objectDetectMaxSpeed = 100;
float currentDistance = 0;
int manuverSpeed = 20;
int driveTime = 0;
int directionDistro = 0;

enum mode {
	wander,
	getOnLine,
	stayOnLine,
	object,
	leaveObject
};
mode Mode = wander;
char greySide;

task objectDetect () {
	while(true && Mode != leaveObject) {
		// Read the sensor
		currentDistance = SensorValue[Sonar] /2.54;
		displayCenteredBigTextLine(8, "Dist: %f.2 in", currentDistance);
		if ((currentDistance) <= detectObjectFarThreshold && currentDistance > detectObjectLowThreshold)
		{
			Mode = object;
			} else if (currentDistance <= detectObjectLowThreshold){
			//turn around  and resume wander
			Mode = leaveObject;
			} else {
			//lost sight of object
			Mode = wander;
		}
	}
}

task lineDetect () {
	while(true) {
		if (Mode == wander) {
			int currentLvalue = SensorValue[ColorSensorL];
			int currentRvalue = SensorValue[ColorSensorR];
			if (currentLvalue < whiteLowerThreshold && currentRvalue < whiteLowerThreshold) {
				Mode = getOnLine;
				int choose = rand() % 2 + 1;
				if (choose == 1) {
					greySide = 'R';
					} else {
					greySide = 'L';
				}
				} else if (currentRvalue < whiteLowerThreshold) { //right sensor hits black
				//turn left
				greySide = 'R';
				Mode = getOnLine;	
			}

			//left sensor hits black
			else if (currentLvalue < whiteLowerThreshold) {
				//turn right
				greySide = 'L';
				Mode = getOnLine;	

			} //end mode==wander
			if (Mode == getOnLine) {
				if (greySide == 'L') {
					//turn left
					motor[MotorL] = 0;
					motor[MotorR] = manuverSpeed;
					} else {
					//turn right
					motor[MotorL] = manuverSpeed;
					motor[MotorR] = 0;
				}
			}
		} else if (Mode == getOnLine) {
			//follow a line
		} else if (Mode == stayOnLine) {

		}
	} //end while 
} //end task

void displayMode(mode theMode) {
	//char[] answer;
	switch (theMode) {
	case wander:
		displayCenteredBigTextLine(1, "M: %s", "wander");
		break;
	case getOnLine :
		displayCenteredBigTextLine(1, "M: %s", "getOnLine");
		break;
	case stayOnLine:
		displayCenteredBigTextLine(1, "M: %s", "stayOnLine");
		break;
	case object:
		displayCenteredBigTextLine(1, "M: %s", "object");
		break;
	case leaveObject:
		displayCenteredBigTextLine(1, "M: %s", "leaveObject");
		break;
	}
}

void stayOnLineMethod() {
			int currentLvalue = SensorValue[ColorSensorL];
			int currentRvalue = SensorValue[ColorSensorR];
			displayBigTextLine(3, "ReflL: %d", currentLvalue);
			displayBigTextLine(5, "ReflR: %d", currentRvalue);
			displayBigTextLine(7, "grey: %d", greySide);
			if (greySide == 'R') {
				//in grey area
				if (currentRvalue >= greyLowerThreshold && currentRvalue <= whiteLowerThreshold) {
					motor[MotorL] = manuverSpeed;
					motor[MotorR] = manuverSpeed;
				} else if (currentRvalue < greyLowerThreshold) {
					//in black area so turn right
					int difference = greyLowerThreshold - currentRvalue;
					//displayCenteredBigTextLine(4, "speRat %f.2", speedRatio);
					float currentSpeed = (manuverSpeed + difference) * 5;
					//displayCenteredBigTextLine(6, "currSpe %f.2", currentSpeed);
					motor[MotorR] = 10;
					motor[MotorL] = currentSpeed;
				} else if (currentRvalue > whiteLowerThreshold) {
					//in white area so turn left
					int difference = currentRvalue - whiteLowerThreshold;
					//displayCenteredBigTextLine(4, "speRat %f.2", speedRatio);
					float currentSpeed = (manuverSpeed + difference) * 3;
					//displayCenteredBigTextLine(6, "currSpe %f.2", currentSpeed);
					motor[MotorR] = currentSpeed;
					motor[MotorL] = 10;
				}
			//end greyside == 'R'
			} else if (greySide == 'L') {
			//in grey area
				if (currentLvalue >= greyLowerThreshold && currentLvalue <= whiteLowerThreshold) {
					motor[MotorL] = manuverSpeed;
					motor[MotorR] = manuverSpeed;
				} else if (currentLvalue < greyLowerThreshold) {
					if (currentRvalue < greyLowerThreshold) {
						greySide = 'R';
					}
					//in black area so turn left
					int difference = greyLowerThreshold - currentLvalue;
					//displayCenteredBigTextLine(4, "speRat %f.2", speedRatio);
					float currentSpeed = (manuverSpeed + difference) * 5;
					//displayCenteredBigTextLine(6, "currSpe %f.2", currentSpeed);
					motor[MotorR] = currentSpeed;
					motor[MotorL] = 10;
				} else if (currentLvalue > whiteLowerThreshold) {
					
					if (currentRvalue < greyLowerThreshold) {
						greySide = 'R';
						/* int seenBlack = 1;
					   int seenWhite = 0;
					 	while (seenBlack < 2) {	
					 		motor[MotorR] = manuverSpeed * -2;
							motor[MotorL] = 0;
							currentRvalue = SensorValue[ColorSensorR];
							if (currentRvalue > whiteLowerThreshold) {
								seenWhite = 1;
							} else if (currentRvalue < greyLowerThreshold && seenWhite > 0) {
								seenBlack = 2;
							}
						}
						*/
							//sleep(1000);
					 } else {
						//in white area so turn right
						int difference = currentLvalue - whiteLowerThreshold;
						//displayCenteredBigTextLine(4, "speRat %f.2", speedRatio);
						float currentSpeed = manuverSpeed + difference * 3;
						//displayCenteredBigTextLine(6, "currSpe %f.2", currentSpeed);
						motor[MotorR] = 10;
						motor[MotorL] = currentSpeed;
					}
				}
			//end greyside == 'L'
			}
}

task main()
{

	startTask(objectDetect);
	startTask(lineDetect);



	//for testing object detect
	//const int distanceToMaintain = 30;
	motor[MotorL] = manuverSpeed;
	motor[MotorR] = manuverSpeed;
	while (true)
	{
		//displayCenteredBigTextLine(1, "M: %s", Mode);
		displayMode(Mode);
		if (Mode == stayOnLine) {

			greySide = 'L';
			stayOnLineMethod();
			// Write the amount of reflected light to the screen
			// This is a value between 0 and 100, where 0 means no reflected
			// light and 100 means all light is being reflected
			


			// Wait 20 ms to get 50 readings per second
			//sleep(20);
			} else if (Mode == getOnLine) {
			int currentLvalue = SensorValue[ColorSensorL];
			int currentRvalue = SensorValue[ColorSensorR];
			displayBigTextLine(3, "ReflectedL: %d", currentLvalue);
			displayBigTextLine(5, "ReflectedR: %d", currentRvalue);


			} else if (Mode == object) {



			//this must be in a task


			// approach object
			if ((currentDistance) <= detectObjectFarThreshold && currentDistance > detectObjectLowThreshold)
			{

				float speedRatio = (currentDistance) / detectObjectFarThreshold;
				displayCenteredBigTextLine(4, "speRat %f.2", speedRatio);
				float currentSpeed = speedRatio * objectDetectMaxSpeed;
				displayCenteredBigTextLine(6, "currSpe %f.2", currentSpeed);
				motor[MotorL] = currentSpeed;
				motor[MotorR] = currentSpeed;
			} else if (currentDistance <= detectObjectLowThreshold) {
				displayCenteredBigTextLine(1, "not Adv ");
				motor[MotorL] = 0;
				motor[MotorR] = 0;
			}


			//Loop to monitor value in Sensor debugger window
			sleep(50);

			} else if (Mode == wander) {
				if (nSysTime - driveTime > 0) {
					if (random(100) > (VEER_RIGHT_CHANCE + directionDistro * DISTRO_OFFSET)) {
						setMotorSpeed(motorA, manuverSpeed + VEER_SPEED_OFFSET);
						setMotorSpeed(motorD, manuverSpeed);
						directionDistro++;
		  		} else {
		  			setMotorSpeed(motorA, manuverSpeed);
						setMotorSpeed(motorD, manuverSpeed + VEER_SPEED_OFFSET);
						directionDistro--;
					}
					//Randomly determine when the car should choose a new direction.
					//The car will turn for a random amount of time within an allowed range.
					driveTime = nSysTime + (random[SWERVE_DUR_MAX - SWERVE_DUR_MIN] + SWERVE_DUR_MIN);
				}
			} else if (Mode == leaveObject) {
			//backup
			motor[MotorL] = -20;
			motor[MotorR] = -20;
			sleep(2000);
			//turn around
			motor[MotorL] = 20;
			motor[MotorR] = -20;
			sleep(2000);
			//pause
			motor[MotorL] = 0;
			motor[MotorR] = 0;
			sleep(2000);
			Mode=wander;
			startTask(objectDetect);
		}

	} //end while true
} //end task main
