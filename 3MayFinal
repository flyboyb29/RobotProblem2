#pragma config(Sensor, S1, ColorSensorR, sensorEV3_Color)
#pragma config(Sensor, S2, Sonar, sensorEV3_Ultrasonic)
#pragma config(Sensor, S4, ColorSensorL, sensorEV3_Color)
#pragma config(Motor, motorA, MotorR, tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor, motorD, MotorL, tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
int VEER_RIGHT_CHANCE = 50;
int VEER_SPEED_OFFSET = 25;
//int TURN_SPEED_OFFSET = 10;
int DISTRO_OFFSET = 10;
int SWERVE_DUR_MIN = 500;
int SWERVE_DUR_MAX = 1500;
// weighted amount for filter
float WEIGHT_AVERAGE = .8;

int WHITE_LOWER_THRESHOLD = 20;
int SWEET_SPOT = 15;
int GREY_LOWER_THRESHOLD = 10; //5
int DETECT_OBJECT_FAR_THRESHOLD = 36;
float DETECT_OBJECT_NEAR_THRESHOLD = 1.9;
int DETECT_OBJECT_MAX_SPEED = 100;
int MANUVER_SPEED = 25;
int TURN_SPEED = 5;


//for sonar
float CurrentFilterOut = 0.0;
float currentDistance = 0;




//for wander
int driveTime = 0;
int directionDistro = 0;

//for line detect
float CurrentFilterOutL = 0.0;
float CurrentFilterOutR = 0.0;
int currentLvalue = 0;
int currentRvalue = 0;
bool LLastSawWhite = true;
bool RLastSawWhite = true;
char greySide;

// the list of the differnt modes of the robot
enum mode {
	wander,
	getOnLine,
	stayOnLine,
	object,
	leaveObject
};

mode Mode = wander;

/*
Using a weighted average, see if the robots sonic sensor finds an object within a certin distance
*/
task objectDetect () {
	float currentSonarValue;
	while(true && Mode != leaveObject) {
		// Read the sensor
		currentSonarValue = SensorValue[Sonar];
		displayCenteredBigTextLine(1, "curSon: %f.2 in", currentSonarValue/ 2.54);
		CurrentFilterOut = currentSonarValue + ((WEIGHT_AVERAGE * CurrentFilterOut) - (WEIGHT_AVERAGE * currentSonarValue));
		currentDistance = CurrentFilterOut / 2.54;
		//currentDistance = SensorValue[Sonar] / 2.54
		displayCenteredBigTextLine(8, "Dist: %f.2 in", currentDistance);
		// decide what to do with the current calculated sonar value.
		if (currentDistance <= DETECT_OBJECT_FAR_THRESHOLD && currentDistance > DETECT_OBJECT_NEAR_THRESHOLD) {
			Mode = object;
			setLEDColor(ledRedFlash);
			} else if (currentDistance <= DETECT_OBJECT_NEAR_THRESHOLD){
			//turn around  and resume wander
			Mode = leaveObject;
			} else {
			//lost sight of object
			if (Mode == object){
					Mode = wander;
			}
		}
	}
}

//task lineSensors() {
//	while(true){
//		currentLvalue = SensorValue[ColorSensorL];
//		currentRvalue = SensorValue[ColorSensorR];
//	}
//}

//task sonarSensors() {
//	float currentSonarValue;
//	while (true) {
//		currentSonarValue = SensorValue[Sonar];
//		CurrentFilterOut = currentSonarValue + ((WEIGHT_AVERAGE * CurrentFilterOut) - (WEIGHT_AVERAGE * currentSonarValue));
//		currentDistance = CurrentFilterOut / 2.54;
//	}
//}

task lineDetect () {
	//startTask (lineSensors);

	while(true) {
		// detect line
		//currentLvalue = SensorValue[ColorSensorL];
		//currentRvalue = SensorValue[ColorSensorR];
		currentLvalue = SensorValue[ColorSensorL];
		CurrentFilterOutL = currentLvalue + WEIGHT_AVERAGE * ( CurrentFilterOutL - currentLvalue);
		currentLvalue = CurrentFilterOutL;
		currentRvalue = SensorValue[ColorSensorR];
		CurrentFilterOutR = currentRvalue + WEIGHT_AVERAGE * ( CurrentFilterOutR - currentRvalue);
		currentRvalue = CurrentFilterOutR;
		if (Mode == wander) {
			//if both hit black at same time, randomly choose one side to be greyside
			if (currentLvalue < WHITE_LOWER_THRESHOLD && currentRvalue < WHITE_LOWER_THRESHOLD) {
				LLastSawWhite = false;
				RLastSawWhite = false;
				setLEDColor(ledOrange);
				Mode = stayOnLine;
				clearTimer(T1);			
				if ((rand() % 2 + 1) == 1) {
					greySide = 'R';
					} else {
					greySide = 'L';
				}
				} else if (currentRvalue < WHITE_LOWER_THRESHOLD) { // right sensor hits black
				//turn left
				RLastSawWhite = false;
				setLEDColor(ledOrange);
				greySide = 'R';
				Mode = stayOnLine;
				clearTimer(T1);
				} else if (currentLvalue < WHITE_LOWER_THRESHOLD) { //turn right
				LLastSawWhite = false;
				setLEDColor(ledOrange);
				greySide = 'L';
				Mode = stayOnLine;
				clearTimer(T1);
			}
		}
	} //end while
} //end task

void displayMode(mode theMode) {
	switch (theMode) {
	case wander:
		displayCenteredBigTextLine(1, "M: %s", "wander");
		break;
	case getOnLine :
		displayCenteredBigTextLine(1, "M: %s", "getOnLine");
		break;
	case stayOnLine:
		displayCenteredBigTextLine(1, "M: %s", "stayOnLine");
		break;
	case object:
		displayCenteredBigTextLine(1, "M: %s", "object");
		break;
	case leaveObject:
		displayCenteredBigTextLine(1, "M: %s", "leaveObject");
		break;
	}
}

void stayOnLineMethod() {
	//int currentLvalue = SensorValue[ColorSensorL];
	//int currentRvalue = SensorValue[ColorSensorR];
	//currentLvalue = SensorValue[ColorSensorL];
	//CurrentFilterOutL = currentLvalue + WEIGHT_AVERAGE * ( CurrentFilterOutL - currentLvalue);
	//currentLvalue = CurrentFilterOutL;
	//currentRvalue = SensorValue[ColorSensorR];
	//CurrentFilterOutR = currentRvalue + WEIGHT_AVERAGE * ( CurrentFilterOutR - currentRvalue);
	//currentRvalue = CurrentFilterOutR;

	// Write the amount of reflected light to the screen
	// This is a value between 0 and 100, where 0 means no reflected
	// light and 100 means all light is being reflected
	displayBigTextLine(3, "ReflL: %d", currentLvalue);
	displayBigTextLine(5, "ReflR: %d", currentRvalue);
	displayBigTextLine(7, "grey: %d", greySide);

	//if either side was on white but now sees grey, it is the grey side
	if (currentRvalue < WHITE_LOWER_THRESHOLD && RLastSawWhite) {
		RLastSawWhite = false;
		greySide = 'R';
		} else if (currentLvalue < WHITE_LOWER_THRESHOLD && LLastSawWhite) {
		LLastSawWhite = false;
		greySide = 'L';
	}
	//if either side sees grey, restart the timer for losing the line
	if (currentLvalue < WHITE_LOWER_THRESHOLD || currentRvalue < WHITE_LOWER_THRESHOLD) {
		clearTimer(T1);
	}
	//if it has been over the amount of time since either saw grey, beep and go to wander
	if (time1[T1] > 1000) {
		playTone(200, 10);
		playTone(300, 5);
		playTone(400, 5);
		playTone(500, 5);
		Mode = wander;
	}
	//left is on white
	if (currentLvalue > WHITE_LOWER_THRESHOLD) {
		LLastSawWhite = true;
	} 
	//right is on white
	if (currentRvalue > WHITE_LOWER_THRESHOLD) {
		RLastSawWhite = true;
	}


	if (greySide == 'R') {
		//in grey area
		if (currentRvalue >= GREY_LOWER_THRESHOLD && currentRvalue <= WHITE_LOWER_THRESHOLD) {
			
			motor[MotorL] = MANUVER_SPEED;
			motor[MotorR] = MANUVER_SPEED;
			
			} else if (currentRvalue < GREY_LOWER_THRESHOLD) {
			//in black area so turn right
			int difference = GREY_LOWER_THRESHOLD - currentRvalue;
			//displayCenteredBigTextLine(4, "speRat %f.2", speedRatio);
			float currentSpeed = MANUVER_SPEED + (difference * 6);
			//displayCenteredBigTextLine(6, "currSpe %f.2", currentSpeed);
			motor[MotorR] = TURN_SPEED;
			motor[MotorL] = currentSpeed;
			} else if (currentRvalue > WHITE_LOWER_THRESHOLD) {
			RLastSawWhite = true;
			//in white area so turn left
			int difference = currentRvalue - WHITE_LOWER_THRESHOLD;
			//displayCenteredBigTextLine(4, "speRat %f.2", speedRatio);
			float currentSpeed = (MANUVER_SPEED + difference) ;
			//displayCenteredBigTextLine(6, "currSpe %f.2", currentSpeed);
			motor[MotorR] = currentSpeed;
			motor[MotorL] = TURN_SPEED;
		}
		//end greyside == 'R'
		} else if (greySide == 'L') {
		//in grey area
		if (currentLvalue >= GREY_LOWER_THRESHOLD && currentLvalue <= WHITE_LOWER_THRESHOLD) {
			motor[MotorL] = MANUVER_SPEED;
			motor[MotorR] = MANUVER_SPEED;
			} else if (currentLvalue < GREY_LOWER_THRESHOLD) {
			//in black area so turn left
			int difference = GREY_LOWER_THRESHOLD - currentLvalue;
			//displayCenteredBigTextLine(4, "speRat %f.2", speedRatio);
			float currentSpeed = MANUVER_SPEED + (difference * 6);
			//displayCenteredBigTextLine(6, "currSpe %f.2", currentSpeed);
			motor[MotorR] = currentSpeed;
			motor[MotorL] = TURN_SPEED;
			} else if (currentLvalue > WHITE_LOWER_THRESHOLD) {
			LLastSawWhite = true;
			//in white area so turn right
			int difference = currentLvalue - WHITE_LOWER_THRESHOLD;
			//displayCenteredBigTextLine(4, "speRat %f.2", speedRatio);
			float currentSpeed = MANUVER_SPEED + difference ;
			//displayCenteredBigTextLine(6, "currSpe %f.2", currentSpeed);
			motor[MotorR] = TURN_SPEED;
			motor[MotorL] = currentSpeed;
		}
	}
	//end greyside == 'L'
}//end stay on line

void objectApproach(){
	if ((currentDistance) <= DETECT_OBJECT_FAR_THRESHOLD &&
		currentDistance > DETECT_OBJECT_NEAR_THRESHOLD){

		float speedRatio = (currentDistance) / DETECT_OBJECT_FAR_THRESHOLD;
		displayCenteredBigTextLine(4, "speRat %f.2", speedRatio);
		float currentSpeed = speedRatio * DETECT_OBJECT_MAX_SPEED;
		//int offsetDistance = currentDistance - 5;
		//float currentSpeed = DETECT_OBJECT_MAX_SPEED * offsetDistance * offsetDistance;
		displayCenteredBigTextLine(6, "currSpe %f.2", currentSpeed);
		motor[MotorL] = currentSpeed;
		motor[MotorR] = currentSpeed;
		} else if (currentDistance <= DETECT_OBJECT_NEAR_THRESHOLD) {
		displayCenteredBigTextLine(1, "not Adv ");
		motor[MotorL] = 0;
		motor[MotorR] = 0;
	}
}

void wanderAround() {
	setLEDColor(ledGreen);
	if (nSysTime - driveTime > 0) {
		if ((float)random(100) > (VEER_RIGHT_CHANCE + directionDistro * DISTRO_OFFSET)) {
			setMotorSpeed(motorA, MANUVER_SPEED + VEER_SPEED_OFFSET);
			setMotorSpeed(motorD, MANUVER_SPEED);
			directionDistro++;
			} else {
			setMotorSpeed(motorA, MANUVER_SPEED);
			setMotorSpeed(motorD, MANUVER_SPEED + VEER_SPEED_OFFSET);
			directionDistro--;
		}
		//Randomly determine when the car should choose a new direction.
		//The car will turn for a random amount of time within an allowed range.
		driveTime = nSysTime + (random[SWERVE_DUR_MAX - SWERVE_DUR_MIN] + SWERVE_DUR_MIN);
	}
}

void leaveObjectMethod() {
	//backup
	motor[MotorL] = -20;
	motor[MotorR] = -20;
	sleep(2000);
	//turn around
	if (random(2) == 1) { // turn right
		motor[MotorL] = 20;
		motor[MotorR] = -20;
		sleep(random(2000) + 2000);
		} else { // turn left
		motor[MotorL] = -20;
		motor[MotorR] = 20;
		sleep(random(2000) + 2000);
	}
	//pause
	motor[MotorL] = 0;
	motor[MotorR] = 0;
	sleep(2000);
	Mode=wander;
	startTask(objectDetect);
}

task main()
{
	startTask(objectDetect);
	startTask(lineDetect);
	//startTask(sonarSensors);

	motor[MotorL] = MANUVER_SPEED;
	motor[MotorR] = MANUVER_SPEED;
	while (true) {
		//displayCenteredBigTextLine(1, "M: %s", Mode);
		displayMode(Mode);
		if (Mode == stayOnLine) {
			stayOnLineMethod();
			} else if (Mode == object) {
			// approach object
			objectApproach();
			} else if (Mode == wander) {
			wanderAround();
			} else if (Mode == leaveObject) {
			leaveObjectMethod();
		}
	} //end while true
} //end task main
