#pragma config(Sensor, S1,     ColorSensorL,   sensorEV3_Color)
#pragma config(Sensor, S2,     Sonar,          sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     ColorSensorR,   sensorEV3_Color)
#pragma config(Motor,  motorA,          MotorR,        tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorB,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorD,          MotorL,        tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Colour sensor modes
0 - modeEV3Color_Reflected
1 - modeEV3Color_Ambient
2 - modeEV3Color_Color
3 - modeEV3Color_Reflected_Raw
4 - modeEV3Color_RGB_Raw
5 - modeEV3Color_Calibration - Not utilized
*/
int whiteLowerThreshold = 12;
int detectObjectFarThreshold = 36;
int detectObjectLowThreshold = 1;
int objectDetectMaxSpeed = 100;
float currentDistance = 0;

enum mode {
	wander,
	line,
	object,
	leaveObject
};
mode Mode = wander;

task objectDetect () {
	while(true && Mode != leaveObject) {
		// Read the sensor
		currentDistance = SensorValue[Sonar] /2.54;
		displayCenteredBigTextLine(8, "Dist: %f.2 in", currentDistance);
		if ((currentDistance) <= detectObjectFarThreshold && currentDistance > detectObjectLowThreshold)
		{
			Mode = object;
			} else if (currentDistance <= detectObjectLowThreshold){
			//turn around  and resume wander
			Mode = leaveObject;
			} else {
			//lost sight of object
			Mode = wander;
		}
	}
}

task lineDetect () {
	while(true) {
		if (Mode == wander) {
		//look for a line
		} else if (Mode == line) {
		//follow a line
		}
	}
}

task main()
{

	startTask(objectDetect);




	//for testing object detect
	//const int distanceToMaintain = 30;
	motor[MotorL] = 20;
	motor[MotorR] = 20;
	while (true)
	{
		displayCenteredBigTextLine(1, "M: %s", Mode);
		if (Mode == line) {
			// Write the amount of reflected light to the screen
			// This is a value between 0 and 100, where 0 means no reflected
			// light and 100 means all light is being reflected
			int currentLvalue = SensorValue[ColorSensorL];
			int currentRvalue = SensorValue[ColorSensorR];
			displayBigTextLine(3, "ReflectedL: %d", currentLvalue);
			displayBigTextLine(5, "ReflectedR: %d", currentRvalue);

			//right sensor hits black
			if (currentLvalue < whiteLowerThreshold) {
				//turn left
				motor[MotorL] = 20;
				motor[MotorR] = 0;
			}

			//right sensor hits black
			else if (currentRvalue < whiteLowerThreshold) {
				//turn right
				motor[MotorL] = 0;
				motor[MotorR] = 20;
			}
			// Wait 20 ms to get 50 readings per second
			sleep(20);
			} else if (Mode == object) {



			//this must be in a task


			// We're too far away, ignore
			if ((currentDistance) <= detectObjectFarThreshold && currentDistance > detectObjectLowThreshold)
			{

				float speedRatio = (currentDistance) / detectObjectFarThreshold;
				displayCenteredBigTextLine(4, "speRat %f.2", speedRatio);
				float currentSpeed = speedRatio * objectDetectMaxSpeed;
				displayCenteredBigTextLine(6, "currSpe %f.2", currentSpeed);
				motor[MotorL] = currentSpeed;
				motor[MotorR] = currentSpeed;
				} else {
				displayCenteredBigTextLine(1, "not Adv ");
				motor[MotorL] = 0;
				motor[MotorR] = 0;				
			}


			//Loop to monitor value in Sensor debugger window
			sleep(50);

			} else if (Mode == wander) {

			} else if (Mode == leaveObject) {
			//backup
			motor[MotorL] = -20;
			motor[MotorR] = -20;
			sleep(2000);
			//turn around
			motor[MotorL] = 20;
			motor[MotorR] = -20;
			sleep(2000);
			//pause
			motor[MotorL] = 0;
			motor[MotorR] = 0;
			sleep(2000);
			Mode=wander;
			startTask(objectDetect);
		}

	} //end while true
} //end task main
